> ## 计算机网络

## 什么是URI
URL+URN组成

## URL格式?
<协议>://<主机>:<端口>/<路径>

## Http请求和响应结构?
请求: 请求行(请求方法+URL+协议版本)+请求头部+请求包体
响应: 响应行(协议版本+状态码+状态码解释)+响应首部+响应包体

## HTTP请求头与请求行之间是什么? 
空行

## 什么是Cookie? Session和Cookie的区别? Cookie被禁用解决办法?
cookie是浏览器端存储的数据, 数据类型为字符串; session是浏览器端存储的数据, 可以为任意数据类型.

cookie被禁用后session也会被禁用, 因为session靠cookie中的sessionId来识别用户.可以通过URL重写技术, 将sessionId写入链接中.

## 浏览器和Servlet通信协议?
HTTP通信协议

## HTTP隧道?
将数据封装在HTTP协议里面, 通过HTTP协议进行传输

## URL解码与编码?
URL中对特殊字符进行编码

## 常见HTTP状态码: 100, 200, 301, 302, 400, 401, 403, 404, 500, 502, 503, 504
- 100:  消息
- 200:  成功消息
- 301: 永久重定向
- 302: 临时重定向
- 400: 错误请求, Bad Request
- 401: 未授权
- 403: forbidden
- 404: not found
- 500: 服务端未知错误
- 502:  Bad Gateway
- 503: 服务器不能正确处理请求
- 504: 网关超时Gateway Time-out

## 301和302区别?
永久重定向与临时重定向

## HTTP状态码502与504区别?
[参考博客](https://www.cnblogs.com/liluxiang/p/9360944.html)

## HTTP请求有哪些?
- put: 上传文件不带验证机制
- get: 获取资源
- post: 传输实体
- head: 获取报文首部, 用以确认URL的有效性
- patch: 对部分资源进行修改
- options: 支持查询方法
- connect:  要求在代理服务器通信时建立隧道
- trace: 追踪路径

## post与get的区别?
get:
- 数据在URL中
- 可以缓存
- 效率高
- 只能接受ASCII码字符的参数类型
- 用于查询
- 大小有限制, 一般为2kb限制

Post:
- 数据在请求实体中
- 不可以缓存
- 效率低
- 支持多编码
- 通常用于修改删除
- 大小无限制
- 不可以缓存

## 为什么get效率高于post?
- get可以缓存, post不能缓存
- post在真正接受数据之前会先将请求头发送给服务器确认, 然后才真正发送数据
- post请求包含更多的请求头
- post不能进行管道化传输

## HTTP协议? 特点?
HTTP协议属于应用层协议, 底层是基于TCP传输

特点: 效率高, 速度快, 无状态

## HTTP长连接与短连接? 非流水线与流水线?
建立TCP连接完成一次数据传输后不关闭TCP, 下一次传输继续在该连接上发送数据.
HTTP1.1之前默认短连接, HTTP1.1后开始默认长连接.

流水线: 发送数据时不等到上一个发送的数据收到ACK确认也可以继续发送数据
非流水线: 等待上一次发送的数据收到ACK后才发送下一个数据

## HTTP1.1与HTTP1.0比较? HTTP2.0与HTTP1.x比较?
HTTP1.1与HTTP1.0比较: 
- HTTP1.1开始默认长连接
- 100消息
- 多个HOST
- 大的数据进行分割
- 过期资源不直接删除而是向服务器确认一下

HTTP2.0与HTTP1.X比较: 
- HTTP2.0支持二进制格式, 之前的为文字格式
- HTTP2.0 首部压缩, 使用哈夫曼算法进行压缩
- HTTP2.0支持多路复用
- HTTP2.0支持服务端推送

## HTTP2.0 多路复用与HTTP1.X中的长连接比较?
多路复用: 一个连接上可以同时发送多个请求
长连接: 多次请求共用一个连接

## HTTP2.0中服务端推送?
客户端不用单独向服务端进行资源请求, 服务端直接解析代码主动向客户端发送资源, 以减少客户端请求次数.

## 一次完整的HTTP请求?
DNS域名解析 -> TCP连接 -> HTTP请求 -> 服务端处理 -> 客户端解析HTML代码, 请求资源 -> 服务端响应资源 -> 客户端接收资源然后对页面进行渲染 -> 呈现给客户端

## HTTP是有状态还是无状态? 如何记住上次请求的用户?
HTTP是无状态的.

通过cookie来记住用户.

## HTTPS交互过程? 与HTTP比较?
HTTPS基于HTTP+SSL(STL), 交互过程: 
1. 客户端选择一套suite cipher发送给服务器
2. 服务器选择hash算法以及加密解密方法, 以证书形式发送给客户端
3. 客户端验证证书合法性并生成一串随机数, 将随机数使用hash算法进行hash, 然后将握手信息+hash结果使用公钥加密发送给服务器
4. 服务器使用秘钥解密握手信息, 对应的hash算法对握手信息进行hash并比较结果是否一致, 一致后也生成握手信息+哈希发送给客户端验证
5. 客户端验证成功后进行正常通信发送数据

区别: 
- HTTPS需要申请证书
- HTTPS是基于HTTP+SSL
- HTTPS端口为443, HTTP端口为80
- HTTP发送的是明文, HTTPS发送的是加密信息

## SMTP, DNS, HTTPS端口号与通信协议?
25, 53, 443

## 什么是RESTful?
一种编程风格, 主要采取动宾格式如"delete/user/id=10"

## 什么是token? 
token是一串字符串用于验证用户信息或防止表单重复提交

## HTTP是基于TCP还是UDP? 
HTTP是基于TCP协议

## TCP三次握手与四次挥手?
三次握手: 
1. 客户端发起SYN报文后进入SYN_SENT状态
2. 服务器接收报文后发送ACK+SYN确认应答报文, 然后进入SYN_RECD状态
3. 客户端收到服务器的确认应答及同步报文后发送ACK报文进入ESTABLISHED状态
4. 服务器接收客户端发来的ACK报文后也进入ESTABLISHED状态

四次挥手: 
1. 客户端发起FIN报文后进入FIN_WAIT1状态
2. 服务端接收报文后发送ACK进入CLOSE_WAIT状态
3. 客户端接收确认应答后进入FIN_WAIT2状态
4. 服务端继续发送未发送完的数据, 发送完数据之后服务端发送FIN+ACK报文然后进入LAST_ACK状态
5. 客户端收到服务端的关闭应答报文后发送ACK确认应答, 然后进入TIME_WAIT状态并等待2MSL.在2MSL时间内未收到服务器的确认应答表示服务器接收到了客户端最后发送的ACK确认应答
6. 服务端CLOSE, 客户端CLOSE

## TCP三次握手的必要性?
三次握手的必要性: 保证双全工通信, 既要保证客户端到服务端的通信也要保证服务端到客户端的通信.并且三次通信保证了客户端可能因为未收到服务端发送的ACK+SYN而导致死锁的情况不会发生

## 为什么不能进行两次握手连接?
如果只进行两次握手即服务端发送ACK+SYN之后就完成通信, 客户端可能因为服务端最后发送的ACK+SYN没有收到而认为服务端没有准备好, 从而导致客户端不会接受服务端的数据, 只等待服务端进行同步确认应答, 这样就导致了死锁的产生.

## 为什么连接的时候是三次握手, 关闭的时候是四次挥手?
客户端在请求关闭后, 服务端可能还有数据没有传输完成, 所以要等待服务端的数据传输完成后才发送一个ACK+FIN报文, 就多了这么一步.

## 如果已经建立了连接, 但客户端忽然出故障了怎么办?
每次传输后都会重置超时重传计时器, 如果两个小时候仍未收到客户端发来的消息, 服务端会每隔75s发送一个确认报文, 连续十次没有响应后服务端认为客户端出现故障, 进而关闭连接.

## TIME_WAIT与CLOSE_WAIT区别?
前者是客户端等待, 后者是服务端等待

## TIME_WAIT为什么要等待2MSL, 可以等待1MSL吗?
不能, 等待1MSL可能会导致客户端发送一个ACK后, 服务端在收到这个ACK的一瞬间刚好启动超时重传FIN, 需要等待这个FIN消失, 所以需要2MSL

## 什么是SYN攻击, 如何检测, 如何防御?
大量半连接请求导致无法处理正常的请求

检测: netstate检测网络连接情况, 是否有大量半连接

防御: 过滤; 增大半连接请求数

## TCP流量控制?
通过窗口滑移来进行流量控制

## 什么是流量控制? 流量控制和拥塞控制是一种东西吗?
拥塞控制是防止拥塞而导致阻塞出现

## 滑动窗口机制?
发送方和接收方协商一段字节长度作为窗口大小.可以防止接收方因为缓存溢出而导致消息丢失.

## 拥塞避免机制?
两种: 超时重传和三次确认

机制: 慢开始, 拥塞避免, 快重传/快恢复

慢开始: 开始时窗口大小为1, 门限初始, 以指数形式增长, 当窗口大小等于门限大小时转为拥塞避免算法

拥塞避免算法: 以线性增长, 当网络出现拥塞时将门限设置为当前窗口的一半然后将当前窗口变为1, 实行慢开始算法

快重传/恢复: 
- 快重传是指当接收方收到失序片断后发送重复确认, 发送方连续收到三次重复确认后就立即发送接收方尚未收到的失序片断, 而不必等待重传计时器到期.
- 快恢复: 当连续收到三次重复确认后将当前门限减半, 当前窗口设置为门限大小, 然后执行拥塞避免算法(当TCP连接和网络出现超时时采用慢开始)

## TCP, UDP的区别? 
面向连接, 可靠速度慢, 速度低
面向无连接, 不可靠, 速度快

## TCP, UDP的应用场景? 
TCP场景: 保证数据安全可靠的传输如HTTP传输

UDP: 效率高, 但不能保证数据可靠, 适用于及时性强的应用如视屏通话, 语音通话


## TCP可靠传输的实现? 
- 超时重传
- 拥塞避免
- 确认序列
- 流量控制

## TCP粘包现象? 如何解决? 
TCP粘包现象主要是因为Nagle算法导致不同的数据因为缓存的原因, 数据之间没有边界标识导致数据无法区分

解决办法: 数据之间需要由边界标识如换行符'\n'

Nagle算法: 为了解决telnet场景下键盘每敲一下就发送一个字符导致传输效率低的问题.
具体: 如果发送方发送包含少量字符的数据包, 发送端会将第一个小包发送出去, 然后将后面收到的字符缓存起来而不立即发送, 直到接收到前一个数据包报文的ACK确认或者当前字符属于紧急数据或者当前缓存数据长度超过MSS(Maximum Segment Size)后才将缓存中组成的一个较大的数据包发送出去.

## 如何用UDP实现可靠性传输?
- 采用确认序列
- 拥塞避免
- 超时重传
- 流量控制


## UDP为什么不会发送粘包现象?
TCP是基于流传播, 而UDP会基于链式传播保证每条消息的完整性.比如发送了三条消息, UDP接收方会在缓存中保存三条消息, 而TCP可能只接受到一条合并消息; UDP需要接受三次, 而TCP则可能只接收一次

## UDP为什么采用链式传播?
因为UDP可能是一对多连接, 为了区分发送方需要分开存储; 而TCP是一对一

## UDP有发送缓冲区吗?
因为是不可靠传输, 所以只把数据从用户态拷贝到内核, 然后立即发送, 不管对方是否接收到, 所以不需要缓冲区.

而TCP因为需要保证可靠性传输, 所以需要由发送缓冲区来实现丢失重传, Nagel算法合并, 滑动窗口等

## TCP, UDP, IP在传输过程中数据的最大值?
链路层在Internet最大传输是1518, 去除首部的18字节后为1500
TCP: 1500 - IP首部(20) - TCP首部(20)
UDP: 1500 - IP首部(20) - UDP首部(8)
IP报文限制在1500字节

## 段, 数据包, 帧?
传输层叫段, 网络层叫数据包, 链路层叫帧

## TCP中keep alive与HTTP中的keep-alive区别?
前者为查看是否存活, 后者为设置存活时间

## 稳定且有上限的带宽条件下, 超大文件从server传输到client端, 选择一个TCP连接快还是构建多个TCP连接快?
在内网上带宽决定传输所以使用单个TCP传输

公网上考虑数据丢失或拥塞现象采用多个TCP传输

## TCP包结构? TCP, UDP, MAC, IP包头有多少字节?
20, 8, 14, 20

## OSI七层模型, TCP/IP四层模型
open system interconnection(OSI):
- 物: 物理层
- 数: 数据链路层, Ethernet
- 网: 网络层, IP, ICMP
- 传: 传输层, TCP, UDP
- 会: 会话层, SMTP
- 表: 表示层, TELNET
- 应: 应用层, HTTP, FTP

TCP/IP四层模型: 
- 数据链路层
- 网络层
- 传输层
- 应用层

## 如何查找域名对应IP? 
浏览器缓存, 系统缓存, MAC上缓存, ISP缓存, DNS缓存, DNS查询

## 有网络层的存在为什么还需要传输层?
能够保证实现多功能传输

## ICMP协议? ping功能? 
网络简单协议, 基于IP,IPv4,功能: 
- 将数据发送到指定目的地
- 报告数据丢弃的原因

ping功能: 
- 检查网络连通性
- 查看响应时间延迟

## 路由功能? 分组和路由选择的区别? 什么是AS? 常用路由选择协议?
功能: 分组和路由选择

AS:路由自治系统, 根据内部网关协议来决定如何路由数据包

路由选择协议: 
- RIP(Routing Information Protocal), 在固定时间间隔中交换各自的整个路由表, 根据跳数(<=15跳)
- OSPF(Open Shortest Path First), 使用泛洪算法发送跟新消息, 根据IP数据报发送信息, 选择路由的度量标准是带宽, 延迟.

## IP地址分类
- A:  8字节, 0-8位为网络标识, 后面24位为主机标识
- B:  16字节
- C:  24字节
- D:  32字节

## ARP
1. 每个主机都会在自己的ARP缓冲区建立一个ARP列表, 以表示IP和MAC的关系
2. 当源主机要发送数据时, 检查ARP是否有对应的IP,如果有直接发送, 如果没有则向本段网络的所有主机发送ARP数据包, 该数据包的内容: 源主机IP地址, 源主机MAC地址, 目的主机的IP地址
3. 本网段所有主机接收ARP包, 检查IP是否为自己的IP, 若不是则忽略; 若是则将自己的MAC地址写入ARP响应包中, 告诉源主机自己是它想要找的MAC地址
4. 源主机收到ARP响应包后, 将目的主机的IP和MAC写入ARP列表, 并利用此信息发送数据

## 数据链路层的作用?
1. 为IP模块接收和发送数据
2. ARP模块发送ARP和接收ARP应答

会解决三个问题: 封装成帧, 透明传输, 差错检测

## 浏览器从一个请求发送到返回经历过程中的优化有哪些?
客户端: 
- 浏览器: 
1. 浏览器开启压缩
2. 资源尽量放在一起
3. css上面js下面
4. 减少不必要的cookie请求
- CND加速
- 反向代理

服务端: 
- 分布式缓存
- 集群: 容错, 负载均衡, 限流
- 异步处理
- 代码优化

## 浏览器访问一个网站的过程? 会用到哪些协议?
DNS->HTTP->TCP->IP->ARP

## CSRF和XSS区别? 各自解决方法?
CSRF:跨域伪造请求, 根据cookie伪造请求.
解决办法: reference; token; 转发请求时需要用户输入, 让用户知道自己在干什么

XSS:跨站脚本, 通过向请求里注入代码
解决办法: 过滤+编码

## 什么是ajax?
异步请求, XmlHttpRequest

## SOAP和REST有什么区别?
SOAP有一定的规范, 如底层数据使用XML格式
REST只是一种代码风格, 没有明确的代码规范

## 什么是XML?
Extention Markup Language(可扩展标记语言)

## PV和UV区别?
page view, user view

## 什么是跨域, 如何解决? 
跨域后js不能使用另一个域的对象

通过JSONP处理

## 客户端缓存过期机制, 缓存验证?
MAX_AGE

ETAG缓存验证

## 数据包的流动?
MAC->IP->TCP->应用层

## forward和redirect的区别?
- forward:服务端转发, 可以共享数据, 速度快, 浏览器看不到URL地址栏变化
- redirect: 服务端给客户端发送一个301/302状态码告知客户端重新定向到指定URL, 用户知道请求变化, 地址栏有改变, 效率较低

## URL重写技术?
当cookie禁用时的一种跟踪用户策略, 将标记信息增添到URL

## IP寻址过程? 
1. 根据路由表搜索匹配主机, 如果找到直接将报文发送给主机
2. 如果匹配主机失败, 则匹配同子网的路由器, 寻找与目的网络号相匹配的表目, 如果找到就发送给指定路由器
这样进行逐跳式进行, 因为IP不知道到达任何目的地的完整路径, 所有IP路由选择只为数据报文提供下一站路由器的IP地址

## 客户端与服务端建立TCP连接三次握手前做了什么? 
在握手前进行DNS查询, DNS迭代查询
- 本地缓存中查询
- 如果没有就到系统配置的DNS服务器中查询
- 如果还没有就到DNS根服务器中进行查询, 然后迭代查询域名
- 最后查询出网址对应IP

DNS查询基于UDP